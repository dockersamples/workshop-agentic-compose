# Hands-on Two: Tools and MCP

## Learning objectives

In this hands-on, you will complete the following objectives:

- Learn how tools work in agentic applications
- Learn how MCP provides tools
- Explore the MCP Gateway
- Connect an app to the MCP Gateway
- Connect, list tools, and run a tool using MCP SDKs

Let's get started!



## Segment One: Understanding tools

For agentic applications, tools are what provide the ability to _do_ things - fetch additional content, perform actions, and more. Without tools, models can only utilize the knowledge it was trained with.

Let's explore a bit to see how tools operate.

1. In the [Visual Chatbot](http://localhost:3000), clear the messages by clicking the **Reset messages** button

2. Add a new user message asking for an interesting fact about the current date and time.

    ```plaintext
    Tell me an interesting fact about the current date and time.
    ```

    The result you should get back should be fairly generic and is likely not to reflect today's current date.

    That's because the model doesn't have access to the current date and time. Let's change that!

3. In the **Tools** tab in the right sidebar, click the **+ Add time tool** button.

    After doing so, you should see a new tool enabled named _get-current-time_.

4. Add another message to the stack asking again. This time though, the tool description will be sent to the API.

    ```plaintext
    How about an interesting fact about now?
    ```

    In the response, you should see a "Tool execution request". This is the model indicating it would like the app to execute a tool and provide it with the results of that execution.

5. Click the **Invoke tool** button. 

    You should then see a new message added to the stack with the current date and time. This message has a new type to it - _tool_. This indicates the message is generated by a tool due to an execution request.

6. Send the messages (which includes the tool execution response).

    You should see a response from the model that now uses the correct date.

7. In the right sidebar, click on the _get-current-time_ tool to view the description of the tool.

    In the modal window, you will see details about the tool, including the description and the parameters for this tool.


> [!IMPORTANT]
> It's important to recognize the flow - the app presents tools and the model decides whether to use a tool or not. It's the app, _not_ the model, that executes the tool. It then sends the result back to the model, which then can continue making progress.


## Segment Two: MCP Servers

Now that we've seen tools, it's time to talk about MCP servers. MCP stands for _Model Context Protocol_ and defines a protocol of communication between an application and external processes. These external processes can provide packaged tools, prompts, resources, and more.

1. In the [Visual Chatbot](http://localhost:3000), reset all of the messages.

2. In the _MCP Servers_ tab in the right sidebar, click the **+ Start weather MCP server** button.

    You will see a _weather_ MCP server started and a listing of "? tools".

3. Tell the application to fetch the list of tools by clicking the **Fetch tools** button.

    You should see the listing now display "3 tools".

4. Switch to the "Tools" tab to see the tools that are provided by the MCP server. You should see the following tools: _weather__get-forecast_, _weather__get-hourly-forecast_, and _weather__get-weather-warnings_. 

5. Add a user message to ask for if there are any current weather warnings in New York City.

    ```plaintext
    Are there any current weather warnings in New York City?
    ```

    You should see a tool invocation request for _weather__get-weather-warnings_, which will be delegated to the MCP server to actually invoke the tool.

    After invoking the tool, you should see a response generated by the model.

> [!IMPORTANT]
> The MCP servers provide a collection of tools and handle the actual invocation of the tool. It is the app's job to collect the listing of tools, perform any necessary filtering, forward those tools to the model, and then delegate requested execution to the MCP server.


## Segment Three: The Docker MCP Gateway

The MCP Server used in the previous segment was code that was bundled in the container. While this MCP server could be shared, it would require any other system to have `node` installed. In fact, many MCP servers require `uvx` (Python) or `npx` (Node).

The [Docker MCP Gateway](https://github.com/docker/mcp-gateway) provides the ability to manage the lifecycle and configuration of containerized MCP servers. It presents itself as an MCP server itself, making it easy to plug into your application.

In this segment, we're going to use the Docker MCP Gateway to launch the [DuckDuckGo MCP server](https://hub.docker.com/r/mcp/duckduckgo).

1. In the workshop editor, open a new terminal and navigate to this directory:

    ```console
    cd 02-tools-and-mcp
    ```

2. Start a MCP Gateway that will provide a basic time server using the following command:

    ```console
    docker run -d --name=mcp-gateway --use-api-socket --network=workshop --network-alias=mcp-gateway docker/mcp-gateway --transport=sse --servers=duckduckgo
    ```

    To explain this command:
      
    - **-d** - run the container in the background
    - **--name=mcp-gateway** - give the new container a specific name (helpful for cleanup later on)
    - **--use-api-socket** - this is a new flag that will mount the Docker socket and inject registry credentials into the container
    - **--network=workshop --network-alias=mcp-gateway** - connect the new container to the network being used by the workshop and give it an alias (or DNS name) of `mcp-gateway`
    - **docker/mcp-gateway** - the name of the container image to run
    - **--transport=sse** - configure the MCP Gateway to use the SSE transport (MCP supports several communication transports)
    - **--servers=duckduckgo** - the name of the MCP server to enable

3. To see the log output, use the `docker logs` command:

    ```console
    docker logs -f mcp-gateway
    ```
    
    You should see output similar to the following:
    
    ```plaintext
    - Reading configuration...
      - Reading catalog from https://desktop.docker.com/mcp/catalog/v2/catalog.yaml
    - Configuration read in 156.873292ms
    - Those servers are enabled: duckduckgo
    - Using images:
      - mcp/duckduckgo@sha256:68eb20db6109f5c312a695fc5ec3386ad15d93ffb765a0b4eb1baf4328dec14f
    > Images pulled in 11.793583ms
      - Verifying images [mcp/duckduckgo]
    > Images verified in 962.265042ms
      - Listing MCP tools...
      - Running mcp/duckduckgo with [run --rm -i --init --security-opt no-new-privileges --cpus 1 --memory 2Gb --pull never -l docker-mcp=true -l docker-mcp-tool-type=mcp -l docker-mcp-name=duckduckgo -l docker-mcp-transport=stdio --network workshop]
    - duckduckgo: [07/21/25 23:41:28] INFO     Processing request of type            server.py:523
    - duckduckgo:                              ListToolsRequest                                   
    - duckduckgo:                     INFO     Processing request of type            server.py:523
    - duckduckgo:                              ListPromptsRequest                                 
    - duckduckgo:                     INFO     Processing request of type            server.py:523
    - duckduckgo:                              ListResourcesRequest                               
    - duckduckgo:                     INFO     Processing request of type            server.py:523
    - duckduckgo:                              ListResourceTemplatesRequest                       
    > duckduckgo: (2 tools)
    > 2 tools listed in 324.740584ms
    > Initialized in 1.463877292s
    > Start sse server on port 8811
    ```

4. With the MCP Gateway up and running, let's connect to it and see what it provides. To do so, we can use the [MCP Inspector](https://github.com/modelcontextprotocol/inspector):

    ```console
    ALLOWED_ORIGINS=http://localhost:6274 HOST=0.0.0.0 DANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector
    ```

    After running this, you will be prompted by VS Code to open a browser tab. Simply click **Cancel** to close the dialog (the URL will go through a proxy that is configured to work).

    The additional flags (`ALLOWED_ORIGINS=... HOST=...`) are because we're running this command inside a container and want to be able to access it from the host.

    The `DANGEROUSLY_OMIT_AUTH` flag is used to make it easy in the workshop setting to access the inspector.

5. Once it's up and running, open your browser to [http://localhost:6274](http://localhost:6274). You should see the inspector.

6. To connect to the MCP server, use the following configuration:

    - **Transport Type:** SSE
    - **URL:** http://mcp-gateway:8811/sse (the connection will be made through the container, allowing use to use the container alias)

    Once you have the settings entered, click the **Connect** button.

7. Go to the **Tools** tab and click the **List Tools** button.

    You should see both a _fetch_content_ and a _search_ tool in the list.

8. Select the _fetch_content_ tool and enter a _url_ of "https://www.docker.com". Click the **Run Tool** button and see the tool run to get the page contents!

9. When you're done, go back to the terminal running the `npx` command and hit `Ctrl+C` to stop the inspector.

> [!IMPORTANT]
> If you watch closely, you'll notice a container start when you run a tool. The Docker MCP Gateway manages the lifecycle of the containerized MCP servers, running them only when they need to run.


## Segment Four: Connecting to the MCP Gateway via code

Now that we have a MCP Gateway up and running, let's connect to it, query the available tools, and invoke a tool!

1. In the workshop editor, open the `02-tools-and-mcp/index.js` file.

2. In the file, add the following inside the `main` function:

    ```javascript
    // Create a client
    const mcpClient = new Client({
        name: "mcp-gateway",
        version: "1.0.0",
    });

    // Create the transport using the SSE protocol
    const mcpTransport = new SSEClientTransport(new URL("http://mcp-gateway:8811/sse"));

    // Connect to the server
    await mcpClient.connect(mcpTransport);

    // Get and list the tools    
    const tools = await mcpClient.listTools();
    console.log('Available tools from MCP:', JSON.stringify(tools, null, 2));

    // Close the client
    await mcpClient.close();
    ```

4. Using the same terminal from before (which is in the `02-tools-and-mcp` directory), install the dependencies:

    ```console
    npm install
    ```

5. Run the program to connect and list the tools being provided by the MCP Gateway:

    ```console
    node ./index.js
    ```

    If everything worked correctly, you should see output similar to the following:

    ```plaintext
    Available tools from MCP: {
      "tools": [
        {
          "name": "fetch_content",
          "description": "\n    Fetch and parse content from a webpage URL.\n\n    Args:\n        url: The webpage URL to fetch content from\n        ctx: MCP context for logging\n    ",
          "inputSchema": {
            "type": "object",
            "properties": {
              "url": {
                "title": "Url",
                "type": "string"
              }
            },
            "required": [
              "url"
            ]
          },
          "annotations": {}
        },
        {
          "name": "search",
          "description": "\n    Search DuckDuckGo and return formatted results.\n\n    Args:\n        query: The search query string\n        max_results: Maximum number of results to return (default: 10)\n        ctx: MCP context for logging\n    ",
          "inputSchema": {
            "type": "object",
            "properties": {
              "max_results": {
                "default": 10,
                "title": "Max Results",
                "type": "integer"
              },
              "query": {
                "title": "Query",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          },
        "annotations": {}
        }
      ]
    }
    ```

    This is the raw output coming from the MCP server and matches what we saw in the MCP Inspector earlier.

6. Let's invoke one of the tools by adding the following _before_ the `await mcpClient.close();`:

    ```javascript
    const response = await mcpClient.callTool({ name: "fetch_content", arguments: { url: "https://www.docker.com" } });
    const pageContents = response.content[0].text;
    console.log(`The first 100 characters of the Docker homepage are: ${pageContents.substring(0, 100)}...`);
    ```

7. If you run the app again, you'll now see a container start up using the `mcp/duckduckgo` image (started by the MCP Gateway) and you'll see output similar to the following:

    ```plaintext
    The Docker homepage currently has the following content: Docker: Accelerated Container Application Development Develop faster Your foundation for secure, int...
    ```

## Clean-up

Hooray! You've completed this hands-on. Before moving on, do the following to clean-up your environment:

1. If you still have the MCP Inspector running, find the terminal it's running in and press `Ctrl+C` to stop it.
2. Stop the MCP Gateway by running the following command:

    ```console
    docker rm -f mcp-gateway
    ```


## Recap

In this hands-on, you accomplished the following:

- Learned how tools and MCP servers operate
- Gained familiarity with using the Docker MCP Gateway
- Connected, listed tools, and ran a tool using MCP SDKs



## Additional resources

- [Model Context Protocol documentation](https://modelcontextprotocol.io) - learn more about the MCP protocol
- [The Docker MCP Gateway repo](http://github.com/docker/mcp-gateway) - learn more about the Docker MCP Gateway
- [Docker MCP Gateway configuration examples](https://github.com/docker/mcp-gateway/tree/main/examples) - see various examples of configuring the MCP Gateway
